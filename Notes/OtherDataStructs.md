The data structures described above are the ones commonly used. Examples of other data structures that have more specialized applications include:
- Skip lists, which store a set of comparable items using a hierarchy of sorted linked lists. Lists higher in the hierarchy consist of increasingly smaller subse¬ quences of the items. Skip lists implement the same functionality as balanced BSTs, but are simpler to code and faster, especially when used in a concurrent context.
- Treaps, which are a combination of a BST and a heap. When an element is inserted into a treap it is assigned a random key that is used in the heap organization. The advantage of a treap is that it is height-balanced with high probability and the insert and delete operations are considerably simpler than for deterministic height-balanced trees such as AVL and red-black trees.
- Fibonacci heaps, which consist of a series of trees. Insert, find minimum, decrease key, and merge (union) run in amortized constant time; delete and delete-minimum take O(logn) time. In particular Fibonacci heaps can be used to reduce the time complexity of Dijkstra's shortest path algorithm from 0((|E|+ |V|)log|V|)to0(|E| + |V|log|V|).
- Disjoint-set data structures, which are used to manipulate subsets. The ba¬ sic operations are union (form the union of two subsets), and find (determine which set an element belongs to). These are used in a number of algorithms, no¬ tably in tracking connected components in an undirected graph and Kruskal's algorithm for the minimum spanning tree. We use the disjoint-set data struc¬
ture to solve the offline minimum problem (Solution 6.8 on Page 189).
- Tries, which are a tree-based data structure used to store strings. Unlike BSTs, nodes do not store keys; instead, the node's position in the tree determines the key it is associated with. Tries can have performance advantages with respect to BSTs and hash tables; they can also be used to solve the longest matching
prefix problem (Solution 19.3 on Page 417).
